# Topic: Parser & Building an Abstract Syntax Tree

### Course: Formal Languages & Finite Automata
### Author: Botnari Ciprian

## Theory
**Parser** is a program or tool that analyzes the structure of a given input, typically a string of code, and determines its grammatical structure according to a specific language's rules. 
**Abstract Syntax Tree (AST)** is a hierarchical representation of the structure of code, generated by the parser, which abstracts away the specific details of the syntax and captures the essential meaning and relationships of the code elements.

## Objectives:
1. Get familiar with parsing, what it is and how it can be programmed.
2. Get familiar with the concept of AST.
3. In addition to what has been done in the 3rd lab work do the following:
   1. Implement the necessary data structures for an AST that could be used for the text I have processed in the 3rd lab work.
   2. Implement a simple parser program that could extract the syntactic information from the input text.

## Implementation 

### parse
* Initializes the **tokens** variable by calling the *tokenize* method on the **lexer** object.
* Sets the **currentTokenIndex** to 0.
* Invokes the *parseProgram* method to initiate the parsing process and checks for any remaining tokens. If there are remaining tokens, an *IllegalArgumentException* is thrown.
```
public void parse() {
    tokens = lexer.tokenize();
    currentTokenIndex = 0;

    // Start the parsing process
    parseProgram();

    // Check if there are any remaining tokens
    if (currentTokenIndex < tokens.size() - 1) {
      throw new IllegalArgumentException("Unexpected token at the end of the input");
    }
}
```

### parseProgram
* Does not take any parameters.
* Uses a while loop to iterate over the **tokens** list as long as the **currentTokenIndex** is less than the size of the list.
* Within each iteration, the code calls the *parseStatement* method, indicating that it expects to parse and handle statements multiple times until all tokens in the list have been processed.
```
private void parseProgram() {
    // program -> statement*
    while (currentTokenIndex < tokens.size()) {
      parseStatement();
    }
}
```

### parseStatement
* Does not take any parameters.
* Retrieves the current token using the *getCurrentToken* method and assigns it to the **currentToken** variable.
* Uses a switch statement to determine which parsing method to call based on the type of the **currentToken**.
```
private void parseStatement() {
   // statement -> printStatement | ifStatement | whileStatement | assignmentStatement
   Token currentToken = getCurrentToken();

    switch (currentToken.getType()) {
      case PRINT -> parsePrintStatement();
      case IF -> parseIfStatement();
      case WHILE -> parseWhileStatement();
      case IDENTIFIER -> parseAssignmentStatement();
      default -> throw new IllegalArgumentException("Unexpected token: " + currentToken);
    }
}
```

## Results
For each input the lexer tokens and the AST are displayed.

===== 1. For input: print A; the tokens are: =====
* (PRINT, print), (WHITESPACE,  ), (IDENTIFIER, A), (SEMICOLON, ;), (END_OF_INPUT, ),
```
PrintStatement { 
   Expression { 
      Identifier { 
         Value: A
      } 
   }
}
```


===== 2. For input: B=10; the tokens are: =====
* (IDENTIFIER, B), (ASSIGNMENT, =), (INT, 10), (SEMICOLON, ;), (END_OF_INPUT, ),
```
AssignmentStatement {
   Expression {
      Identifier {
         Value: B
      }
      Integer {
         Value: 10
      }
   }
}
```


===== 3. For input: if(a==b){return true;}else{return false;} the tokens are: =====
* (IF, if), (LEFT_PAREN, (), (IDENTIFIER, a), (EQUALS, ==), (IDENTIFIER, b), (RIGHT_PAREN, )), (LEFT_BRACE, {), (RETURN, return), (WHITESPACE,  ), (BOOLEAN, true), (SEMICOLON, ;), (RIGHT_BRACE, }), (ELSE, else), (LEFT_BRACE, {), (RETURN, return), (WHITESPACE,  ), (BOOLEAN, false), (SEMICOLON, ;), (RIGHT_BRACE, }), (END_OF_INPUT, ),
```
IfStatement {
   Expression {
      Identifier {
         Value: a
      }
      Operator {
         Value: ==
      }
      Identifier {
         Value: b
      }
   }
   Program {
      Keyword {
         Value: return
      }
      Boolean {
         Value: true
      }
   }
}
ElseStatement {
   Program {
      Keyword {
         Value: return
      }
      Boolean {
         Value: false
      }
   }
}
```

===== 4. For input: while(i<10){print i;i++;} the tokens are: =====
* (WHILE, while), (LEFT_PAREN, (), (IDENTIFIER, i), (LESS_THAN, <), (INT, 10), (RIGHT_PAREN, )), (LEFT_BRACE, {), (PRINT, print), (WHITESPACE,  ), (IDENTIFIER, i), (SEMICOLON, ;), (IDENTIFIER, i), (PLUS, +), (PLUS, +), (SEMICOLON, ;), (RIGHT_BRACE, }), (END_OF_INPUT, ),
```
WhileStatement {
   Expression {
      Identifier {
         Value: i
      }
      Operator {
         Value: <
      }
      Integer {
         Value: 10
      }
   }
   Program {
      PrintStatement {
         Expression {
            Identifier {
               Value: i
            }
      }
      Identifier {
         Value: i
      }
      Operator {
         Value: ++
      }
   }
}
```

## Conclusions 
In conclusion, I have successfully achieved the objectives of the laboratory, which were to familiarize myself with parsing and its programming implementation, as well as gain an understanding of Abstract Syntax Trees (ASTs). Throughout this journey, I have expanded my knowledge and skills in these areas.

Building upon the work I did in the third lab, I went on to implement the AST that could effectively represent the hierarchical structure of the text I had processed. This allowed me to organize the syntactic information in a systematic manner, enhancing my understanding of the underlying code.

Additionally, I developed a simple parser program that proved to be invaluable in extracting the syntactic details from the input text. Leveraging my understanding of parsing techniques, I was able to automate the process and generate the corresponding ASTs. This parser program served as a practical tool, aiding me in comprehending the code structure more effectively.

Through these tasks, I have gained hands-on experience in working with parsing and ASTs, sharpening my programming abilities and deepening my understanding of these core concepts. Not only have I accomplished my initial objectives, but I have also broadened my capabilities in processing and analyzing textual data.

Finally, this project has been an enlightening and enriching experience for me. It has provided me with valuable insights into parsing, ASTs, and their real-world applications. I am now equipped with the knowledge and skills to tackle more complex parsing tasks and explore further advancements in this field. This project has undoubtedly enhanced my growth as a student, and I look forward to applying these newfound skills in future endeavors.



