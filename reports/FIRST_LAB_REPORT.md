# Topic: Intro to formal languages. Regular grammars. Finite Automata.

### Course: Formal Languages & Finite Automata
### Author: Botnari Ciprian

----

## Theory
Formal languages are sets of strings that can be described by rules. Finite automata are models of computation that follow a set of rules to accept or reject strings. A language is recognized by a finite automaton if all the strings in the language can be accepted by the automaton. It is used in various applications, like lexical analysis for compilers and natural language processing.


## Objectives:

* Understand what a language is and what it needs to have in order to be considered a formal one.
* Provide the initial setup for the evolving project: 

  a. Create a local && remote repository of a VCS hosting service

  b. Choose a programming language

  c. Create a separate folder the report will be kept

* According to my variant 6, get the grammar definition and do the following tasks:

  a. Implement a type/class for the grammar;

  b. Add one function that would generate 5 valid strings from the language expressed by the given grammar

  c. Implement some functionality that would convert and object of type Grammar to one of type Finite Automaton;

  d. For the Finite Automaton, add a method that checks if an input string can be obtained via the state transition from it


## Implementation description

### Generate Word
* The function recursively generates a string by applying the grammar rules associated with the given non-terminal symbol. 

* It initializes an empty StringBuilder to build the final output string and a list of possible productions that have the given symbol as their left-hand side. 

* The function then selects a random production from the list and retrieves the right-hand side of the selected production.

* It loops through each character in the right-hand side string and either recursively calls itself with the non-terminal character or appends the character to the StringBuilder, depending on whether the character is a non-terminal symbol or a terminal symbol, respectively. 

* Finally, the function returns the contents of the StringBuilder as a string, which represents the output string generated by applying the grammar rules associated with the given non-terminal symbol.

```
 private String generateWord(char symbol) {
        StringBuilder result = new StringBuilder();

        ArrayList<Production> possibleProductions = new ArrayList<>();
        for (Production production : this.productions) {
            if (production.getLeftSide().charAt(0) == symbol) {
                possibleProductions.add(production);
            }
        }

        Random random = new Random();
        int randomIndex = random.nextInt(possibleProductions.size());
        String rightSide = possibleProductions.get(randomIndex)
        .getRightSide();

        for (int i = 0; i < rightSide.length(); i++) {
            char currentSymbol = rightSide.charAt(i);
            if (isNonTerminal(currentSymbol)) {
                result.append(generateWord(currentSymbol));
            } else {
                result.append(currentSymbol);
            }
        }

        return result.toString();
    }
```

### to Finite Automaton
* The method converts a context-free grammar into a finite automaton. 

* It constructs the set of possible states by taking the union of non-terminal variables with the final state 'X'. 

* The method defines the alphabet as the set of terminal variables. 

* It constructs the set of transitions by mapping the productions of the grammar to transitions in the finite automaton. 

* The method sets the initial state to be the starting character of the grammar and the final state to be 'X'. 

* Finally, the method returns a new instance of a FiniteAutomaton class, which represents the converted grammar as a finite automaton.

```
public FiniteAutomaton toFiniteAutomaton() {
        // Q - possible states
        char[] possibleStates = this.nonTerminalVariables;
        char[] newPossibleStates = new char[possibleStates.length + 1];
        System.arraycopy(possibleStates, 0, newPossibleStates, 0, possibleStates.length);
        newPossibleStates[newPossibleStates.length - 1] = 'X';
        possibleStates = newPossibleStates;

        // Σ - Alphabet
        char[] alphabet = terminalVariables;

        // Δ - Transitions
        Transition[] transitions = new Transition[this.productions.length];
        int i = 0;
        for (Production production : this.productions) {
            char currentState = production.getLeftSide().charAt(0);
            char nextState = production.getRightSide().length() > 1
                    ? production.getRightSide().charAt(1)
                    : 'X';
            char transitionLabel = production.getRightSide().charAt(0);

            transitions[i] = new Transition(currentState, nextState, transitionLabel);
            i++;
        }

        // q0 - Initial state
        char initialState = startingCharacter;

        // F - Final State
        char[] finalStates = new char[]{'X'};

        return new FiniteAutomaton(possibleStates, alphabet, transitions, initialState, finalStates);
    }
```

### is Word Valid
* The method checks if a given input string is a valid word of the grammar by simulating the non-deterministic finite automaton that recognizes the grammar.

* It uses a set of current states, initially set to the epsilon closure of the initial state, to track the possible states that the automaton could be in after reading the first character of the input string.

* The method loops through each character of the input string and updates the set of possible states based on the transitions from the current states that consume the current character. 

* If the set of possible states is empty at any point, the method returns false. 

* After processing the entire input string, the method checks if any of the final states of the automaton are present in the set of possible states, and returns true if a final state is found, and false otherwise.

```
public boolean isWordValid(String str) {
        Set<Character> currentStates = epsilonClosure(this.initialState);

        for (char c : str.toCharArray()) {
            Set<Character> nextStates = new HashSet<>();

            for (char currentState : currentStates) {
                for (Transition t : this.transitions) {
                    if (t.getCurrentState() == currentState &&
                        t.getTransitionLabel() == c) {
                        nextStates.addAll(epsilonClosure(t.getNextState()));
                    }
                }
            }

            if (nextStates.isEmpty()) {
                return false;
            }

            currentStates = nextStates;
        }

        for (char finalState : this.finalStates) {
            if (currentStates.contains(finalState)) {
                return true;
            }
        }

        return false;
    }
```

## Results
1. Generate 5 random words: 
    * ce 
    * cbcce
    * cennm
    * cbnnnccffe
    * cfenm

2. FiniteAutomaton { 
	* Q (states) = [S, I, J, K, X] 
	* Σ (alphabet) = [a, b, c, e, n, f, m] 
	* Δ (transitions) = [I, J, I, J, S, K, K, X, X] 
	* q0 (initial state) = S 
	* F (final States) = [X] <br>
}

3. Test cases for isWordValid method: 
    * ce: true
    * cm: true
    * cc: false
    * cenm: true
    * acenm: false
    * cet: false
    * cfbccbnccenm: true
    * cbccbccbnnccfem: true
    * cennnnnnnnnnn: false
    * cennnnnnnnnnnm: true
    * hello: false

## Conclusions 
As a student who just finished the laboratory work, I can say that the objectives were met as I was able to gain a better understanding of formal languages and implement a grammar in code. The initial setup of the project was straightforward, with the main focus being on the implementation of Variant 6. Creating a class for the grammar, generating valid strings, and converting the object to a finite automaton were all valuable exercises that helped me to solidify my understanding of the theory. The final task of checking if an input string was valid according to the automaton's state transition was a good way to see how theory can be applied in practice. Overall, the laboratory work provided an excellent opportunity to learn about formal languages and how they can be implemented in code.




















